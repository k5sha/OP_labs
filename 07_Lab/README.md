# Лабораторна робота №7
### Тема: Шаблон «Стратегія»

### Виконано групою номер **12**

[Сама лабороторна](https://docs.google.com/document/d/11TIlRNGAvJX2DmEZl3nB4YGJHswx3ytd/edit)

### Контрольні питання:

### 1. Що таке патерни (шаблони) проектування? 

Патерни (шаблони) проектування — це загальні рішення для повторюваних проблем у програмному забезпеченні. Вони представляють собою готові приклади структур, алгоритмів чи об'єктів, які допомагають розробникам писати більш структурований, зрозумілий та легший для підтримки код.

1) Для чого вони потрібні?
      - Знизити складність коду
      - Забезпечити гнучкість.
      - Спрощувати взаємодію між командами
      - Повторне використання.


### 2. Для чого потрібен шаблон «Стратегія»?

Шаблон проектування «Стратегія» (Strategy) використовується для того, щоб визначати сімейство алгоритмів, інкапсулювати кожен з них і робити їх взаємозамінними. За допомогою цього патерну можна змінювати алгоритм незалежно від клієнтів, які ним користуються.

### 3. Пояснити смисл кожного з принципів проектування SOLID.

1. Single Responsibility Principle (SRP) — Принцип єдиного обов'язку
   - Цей принцип говорить про те, що кожен клас повинен мати лише одну відповідальність або причину для зміни. Клас має виконувати тільки одне завдання, а всі його методи повинні бути тісно пов'язані з цією задачею.
   - Сенс: Якщо клас відповідає за багато різних задач, зміна в одній з них може вплинути на інші. Це ускладнює підтримку і тестування коду. Розділяючи обов’язки між різними класами, ми робимо код більш структурованим і незалежним.

2. Open/Closed Principle (OCP) — Принцип відкритості/закритості
   - Код повинен бути відкритий для розширення, але закритий для модифікації. Це означає, що потрібно створювати класи таким чином, щоб додавати нову функціональність через розширення (спадкування, імплементація), а не через зміну існуючого коду.
   - Сенс: Коли ми змінюємо код, ми ризикуємо порушити існуючу логіку і ввести нові помилки. Розширюючи функціональність без модифікації базових класів, ми зменшуємо ризик порушення існуючої роботи програми.

3. Liskov Substitution Principle (LSP) — Принцип підстановки Барбари Лісков
   - Класи-нащадки повинні мати можливість заміняти батьківські класи без порушення роботи програми. Це означає, що об’єкт класу-нащадка має працювати так само коректно, як і об’єкт класу-батька.
   - Сенс: Якщо клас-нащадок змінює поведінку батьківського класу так, що його використання викликає помилки або несподівані результати, це порушує принцип підстановки. Всі класи-нащадки повинні відповідати контракту, який був визначений у батьківському класі.

4. Interface Segregation Principle (ISP) — Принцип розділення інтерфейсів
   - Клієнти не повинні залежати від інтерфейсів, які вони не використовують. Тобто інтерфейси повинні бути вузькими та конкретними, а не великими і загальними.
   - Сенс: Великі інтерфейси змушують класи реалізовувати методи, які їм не потрібні. Це ускладнює підтримку коду і збільшує залежність класів від невикористовуваної функціональності.

5. Dependency Inversion Principle (DIP) — Принцип інверсії залежностей
   - Модулі верхнього рівня не повинні залежати від модулів нижчого рівня. Обидва типи модулів повинні залежати від абстракцій. Іншими словами, код повинен залежати не від конкретних реалізацій, а від абстракцій (інтерфейсів або абстрактних класів).
   - Сенс: Якщо класи залежать від конкретних реалізацій інших класів, то зміни в цих реалізаціях можуть спричинити ланцюгові зміни в інших частинах програми. Це знижує гнучкість і підтримуваність коду.

### 4. Для кожного з принципів SOLID навести фрагмент коду, який його порушує, пояснити сутність проблеми та запропонувати спосіб її вирішення.

1. Принцип єдиного обов’язку (SRP)

```Java
class Report {   //Порушення: Клас виконує більше одного завдання.
    public void generateReport() {
        // Генерація даних для звіту
    }

    public void saveToFile(String fileName) {
        // Збереження звіту у файл
    }
}
```

+ _Проблема_: Клас Report відповідає і за генерацію звіту, і за його збереження. Це порушує принцип єдиного обов'язку, оскільки при зміні способу збереження звіту доведеться змінювати цей клас.

+ _Рішення_: Розділити обов’язки на окремі класи.

```Java
class Report {
    public void generateReport() {
        // Генерація даних для звіту
    }
}

class ReportSaver {
    public void saveToFile(Report report, String fileName) {
        // Збереження звіту у файл
    }
}    // Тепер клас Report відповідає лише за генерацію звіту, а клас ReportSaver — за його збереження.
```

2. Принцип відкритості/закритості (OCP)

```Java
class PaymentProcessor {    //Порушення: Додавання нових функцій вимагає зміни існуючого коду.
    public void processPayment(String paymentType) {
        if (paymentType.equals("credit")) {
            // Обробка кредитної картки
        } else if (paymentType.equals("paypal")) {
            // Обробка PayPal
        }
    }
}
```

+ _Проблема_: Щоразу, коли з’являється новий тип оплати, доведеться змінювати метод processPayment, порушуючи принцип закритості для модифікацій.

+ _Рішення_: Використати інтерфейси для різних способів оплати.

```Java
interface PaymentMethod {
    void process();
}

class CreditCardPayment implements PaymentMethod {
    public void process() {
        // Обробка кредитної картки
    }
}

class PayPalPayment implements PaymentMethod {
    public void process() {
        // Обробка PayPal
    }
}

class PaymentProcessor {
    public void processPayment(PaymentMethod paymentMethod) {
        paymentMethod.process();
    }
}    //Тепер додавання нових способів оплати не вимагає змін у класі PaymentProcessor.
```

3. Принцип підстановки Лісков (LSP)

```Java
class Bird {    //Порушення: Клас-нащадок порушує поведінку батьківського класу.
    public void fly() {
        // Птахи можуть літати
    }
}

class Ostrich extends Bird {
    @Override
    public void fly() {
        throw new UnsupportedOperationException("Страуси не можуть літати");
    }
}
```

+ _Проблема_: Клас-нащадок Ostrich не відповідає контракту батьківського класу Bird, оскільки він
не може літати, але змушений реалізовувати метод fly.

+ _Рішення_: Винести можливість польоту в окремий інтерфейс.

```Java
interface Flyable {
    void fly();
}

class Bird {
    // Загальні характеристики птахів
}

class FlyingBird extends Bird implements Flyable {
    public void fly() {
        // Реалізація польоту
    }
}

class Ostrich extends Bird {
    // Страус не літає
}    //Тепер лише птахи, які можуть літати, реалізують інтерфейс Flyable.
```

4. Принцип розділення інтерфейсів (ISP)

```Java
interface Worker {  //Порушення: Інтерфейс занадто великий і змушує класи реалізовувати                                //методи,які їм не потрібні.
    void work();
    void eat();
}

class Robot implements Worker {
    public void work() {
        // Робот працює
    }

    public void eat() {
        // Роботи не їдять, але змушені реалізувати цей метод
    }
}
```

+ _Проблема_: Клас Robot змушений реалізовувати метод eat, який йому не потрібен.

+ _Рішення_: Розділити інтерфейс на два менші.

```Java
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class Human implements Workable, Eatable {
    public void work() {
        // Людина працює
    }

    public void eat() {
        // Людина їсть
    }
}

class Robot implements Workable {
    public void work() {
        // Робот працює
    }
}   //Тепер класи реалізують лише ті методи, які їм потрібні.
```

5. Принцип інверсії залежностей (DIP)

```Java
class LightBulb {   //Порушення: Вищий модуль залежить від нижчого, замість абстракції.
    public void turnOn() {
        // Увімкнення лампи
    }

    public void turnOff() {
        // Вимкнення лампи
    }
}

class Switch {
    private LightBulb lightBulb;

    public Switch(LightBulb lightBulb) {
        this.lightBulb = lightBulb;
    }

    public void operate() {
        lightBulb.turnOn();
    }
}
```

+ _Проблема_: Клас Switch напряму залежить від конкретного класу LightBulb, що порушує принцип інверсії залежностей.

+ _Рішення_: Введення абстракції через інтерфейс.

```Java
interface Switchable {
    void turnOn();
    void turnOff();
}

class LightBulb implements Switchable {
    public void turnOn() {
        // Увімкнення лампи
    }

    public void turnOff() {
        // Вимкнення лампи
    }
}

class Switch {
    private Switchable device;

    public Switch(Switchable device) {
        this.device = device;
    }

    public void operate() {
        device.turnOn();
    }
}    //Тепер клас Switch залежить від абстракції Switchable, а не від конкретної реалізації            //LightBulb, що робить код більш гнучким і модульним.
```  

### 5. Що означають терміни «компонент» та «залежність» (component, dependency).

+ _Компонент_ у контексті програмного забезпечення — це незалежна і взаємозамінна частина програми, яка виконує певну функцію або набір функцій. Компоненти можна розглядати як будівельні блоки, з яких складається програма.

+ _Залежність_ — це ситуація, коли один компонент або клас покладається на інший для виконання своєї роботи. Якщо компонент не може функціонувати без іншого компонента, ми говоримо, що перший має залежність від другого.

### 6. В чому полягає принцип явного використання залежностей (Explicit Dependencies Principle)?

Принцип явного використання залежностей (Explicit Dependencies Principle) полягає в тому, що клас повинен явно отримувати всі свої залежності через конструктор або інші механізми ін'єкції, а не створювати їх всередині себе або отримувати з глобального контексту. Іншими словами, залежності мають бути передані ззовні, щоб було чітко зрозуміло, на що клас покладається для своєї роботи.

### 7. В чому полягають переваги і недоліки явного (explicit) і неявного (implicit) використання залежностей? 

1. Явне використання залежностей (_Explicit Dependencies_)

+ Переваги:
   1) Прозорість.
   2) Легке тестування.
   3) Гнучкість і розширюваність.
   4) Контроль над залежностями.

 + Недоліки:
   1) Збільшення кількості коду
   2) Потреба в додаткових інструментах
   3) Складність при малих проектах

 2. Неявне використання залежностей (_Implicit Dependencies_)
 
 + Переваги:
    1) Менше коду
    2) Менша складність у простих проектах.
    3) Швидкість розробки

 + Недоліки:
    1) Приховані залежності
    2) Складність тестування
    3) Жорсткі зв'язки
    4) Проблеми з розширенням
   
### 8. Пояснити смисл термінів «Зв'язність» (Coupling) та «Пов'язаність» (Cohesion).

Зв'язність — це міра того, наскільки один модуль або компонент залежить від інших модулів чи компонентів у системі. Висока зв'язність означає, що компоненти сильно залежать один від одного, тоді як низька зв'язність свідчить про незалежність компонентів і їхню можливість працювати окремо.
