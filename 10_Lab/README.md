# Лабораторна робота №10
### Тема: Колекції. Списки

### Виконано групою номер **12**

[Сама лабороторна](https://docs.google.com/document/d/116OM0_99sPzryokrjnKYvi78mqHb1ykO/edit)

### Контрольні питання:

### 1. Для чого призначений Collections Framework?

Collections Framework у Java призначений для ефективної роботи з групами об'єктів, надаючи стандартизовані інтерфейси та класи для зберігання, обробки та маніпулювання колекціями даних. Він спрощує розробку, підвищує продуктивність та забезпечує взаємодію між різними API.

### 2. В чому полягає різниця між масивами та колекціями?

Масиви та колекції в Java є структурами даних для зберігання об'єктів, але вони мають суттєві відмінності:

1. Розмір:
   + _Масиви_: Мають фіксований розмір, визначений під час створення. Після ініціалізації змінити розмір масиву неможливо.
   + _Колекції_: Динамічні за розміром; можуть автоматично збільшуватися або зменшуватися в залежності від додавання чи видалення елементів.

2. Тип даних:
   + _Масиви_: Можуть зберігати як примітивні типи (наприклад, int, char), так і об'єкти.
   + _Колекції_: Працюють лише з об'єктами. Для зберігання примітивних типів необхідно використовувати відповідні обгортки (наприклад, Integer для int).

3. Функціональність:
   + _Масиви_: Пропонують базові операції, такі як доступ за індексом та ітерація.
   + _Колекції_: Надають широкий набір методів для маніпуляції даними: додавання, видалення, пошук, сортування тощо.

4. Продуктивність:
   + _Масиви_: Забезпечують швидкий доступ до елементів за індексом, оскільки дані зберігаються послідовно в пам'яті.
   + _Колекції_: Продуктивність залежить від конкретної реалізації. Наприклад, ArrayList забезпечує швидкий доступ за індексом, тоді як LinkedList оптимізований для швидкого додавання та видалення елементів.

5. Гнучкість:
   + _Масиви_: Менш гнучкі через фіксований розмір та обмежену функціональність.
   + _Колекції_: Більш гнучкі, оскільки пропонують різні структури даних (списки, множини, мапи) та методи для роботи з ними.

### 3. Які особливі властивості є у списків порівняно з іншими типами колекцій?

Списки (інтерфейс List) у Java мають кілька особливих властивостей, які відрізняють їх від інших типів колекцій, таких як множини (Set) та мапи (Map):

1. Порядок елементів:
   + Списки зберігають елементи в певному порядку, тобто кожен елемент має свій індекс. Це дозволяє звертатися до елементів за їхнім положенням у списку.

2. Дублювання елементів:
   +  Списки допускають наявність однакових елементів. Це означає, що один і той самий об'єкт може з'являтися в списку кілька разів.

3. Доступ за індексом:
   + Списки надають можливість доступу до елементів за їхнім індексом через метод get(int index). Це спрощує маніпуляції з елементами на конкретних позиціях.

4. Вставка та видалення за індексом:
   + Списки дозволяють вставляти (add(int index, E element)) та видаляти (remove(int index)) елементи на конкретних позиціях, що забезпечує гнучкість у роботі з даними.

5. Пошук елементів:
   + Списки підтримують методи indexOf(Object o) та lastIndexOf(Object o), які повертають індекс першого або останнього входження вказаного елемента.

### 4. Чим списки відрізняються від масивів?

Списки (List) та масиви в Java є структурами даних для зберігання елементів, але вони мають суттєві відмінності:

1. Розмір:
   + _Масиви_: Мають фіксований розмір, визначений під час створення. Після ініціалізації змінити розмір масиву неможливо.
   + _Списки_: Динамічні за розміром; можуть автоматично збільшуватися або зменшуватися в залежності від додавання чи видалення елементів.

2. Тип даних:
   + _Масиви_: Можуть зберігати як примітивні типи (наприклад, int, char), так і об'єкти.
   + _Списки_: Працюють лише з об'єктами. Для зберігання примітивних типів необхідно використовувати відповідні обгортки (наприклад, Integer для int).

3. Функціональність:
   +  _Масиви_: Пропонують базові операції, такі як доступ за індексом та ітерація.
   +  _Списки_: Надають широкий набір методів для маніпуляції даними: додавання, видалення, пошук, сортування тощо.

4. Продуктивність:
   +  _Масиви_: Забезпечують швидкий доступ до елементів за індексом, оскільки дані зберігаються послідовно в пам'яті.
   + _Списки_: Продуктивність залежить від конкретної реалізації. Наприклад, ArrayList забезпечує швидкий доступ за індексом, тоді як LinkedList оптимізований для швидкого додавання та видалення елементів.

5. Гнучкість:
   +  _Масиви_: Менш гнучкі через фіксований розмір та обмежену функціональність.
   +  _Списки_: Більш гнучкі, оскільки пропонують різні структури даних (списки, множини, мапи) та методи для роботи з ними.

### 5. Чим ArrayList відрізняється від LinkedList? Який з них у яких випадках краще використовувати?

ArrayList та LinkedList — це дві різні реалізації інтерфейсу List у Java, кожна з яких має свої особливості та підходить для різних сценаріїв використання.

Основні відмінності між ArrayList та LinkedList:

1. Структура даних:
    + ArrayList: Використовує динамічний масив для зберігання елементів.
    + LinkedList: Реалізований як двозв'язний список, де кожен елемент містить посилання на попередній та наступний елементи.

2. Доступ за індексом:
    + ArrayList: Забезпечує швидкий доступ до елементів за індексом з часовою складністю O(1).
    + LinkedList: Доступ за індексом вимагає проходження списку від початку або кінця до потрібного елемента, що має часову складність O(n).

3. Вставка та видалення елементів:
    + ArrayList: Вставка або видалення елементів у середині списку може бути повільною, оскільки потребує зсуву інших елементів; часова складність O(n).
    + LinkedList: Вставка та видалення елементів у будь-якому місці списку відбувається швидко, оскільки достатньо змінити посилання сусідніх елементів; часова складність O(1) для операцій на початку або кінці списку.

4. Використання пам'яті:
   + ArrayList: Використовує менше пам'яті, оскільки зберігає лише самі елементи.
   + LinkedList: Використовує більше пам'яті через зберігання додаткових посилань на сусідні елементи.

### 6. Що таке Iterator? В чому полягають переваги використання ітератора у порівнянні з класичним циклом ”for(int i=0; i<collection.size(); i++) { /* ... */  }”?
Ітератор в Java — це об'єкт, який дозволяє послідовно обходити елементи колекції без розкриття її внутрішньої структури. Він надає методи для перевірки наявності наступного елемента (hasNext()), отримання наступного елемента (next()) та, за потреби, видалення поточного елемента (remove()).

Переваги використання ітератора порівняно з класичним циклом for(int i=0; i<collection.size(); i++) { /* ... */ }:

1. Універсальність:
    + Ітератори можуть використовуватися з будь-якими колекціями, незалежно від їх типу та реалізації. Це забезпечує єдиний підхід до обходу елементів різних структур даних.

2. Безпечне видалення елементів:
    + Використовуючи метод remove() ітератора, можна безпечно видаляти елементи під час ітерації, уникнувши виникнення ConcurrentModificationException. У класичному циклі видалення елементів може призвести до непередбачуваної поведінки.

3. Підтримка різних структур даних:
    + Деякі колекції, такі як LinkedList, не забезпечують швидкого доступу за індексом. Використання ітератора дозволяє ефективно обходити такі колекції без втрати продуктивності.

4. Зменшення помилок:
    + Ітератори автоматично обробляють межі колекції, зменшуючи ризик помилок, пов'язаних з неправильним визначенням умов циклу або індексації.

5. Підтримка поліморфізму:
    + Ітератори дозволяють працювати з колекціями через їхні інтерфейси, що сприяє більш гнучкому та розширюваному коду.

### 7. Що таке типізовані та нетипізовані колекції?

Типізовані колекції (generic collections) використовують параметри типів, що дозволяє визначити, які саме об'єкти можуть зберігатися в колекції. Це забезпечує перевірку типів на етапі компіляції, зменшуючи кількість помилок під час виконання програми.

Приклад типізованої колекції:

```Java
List<String> list = new ArrayList<>();
list.add("Hello");
String item = list.get(0); // Не потребує приведення типів
```

Нетипізовані колекції (raw types) не мають визначеного параметра типу, тому можуть зберігати об'єкти будь-якого типу. Однак це призводить до відсутності перевірки типів на етапі компіляції та може спричинити помилки під час виконання програми.

Приклад нетипізованої колекції:

```Java
List list = new ArrayList();
list.add("Hello");
String item = (String) list.get(0); // Потребує явного приведення типу
```

### 8. Для чого потрібен інтерфейс RandomAccess?

Інтерфейс RandomAccess у Java є маркерним інтерфейсом, який використовується для позначення реалізацій інтерфейсу List, що підтримують швидкий (зазвичай за постійний час) доступ до елементів за індексом. Він не містить методів і слугує індикатором для оптимізації роботи з колекціями.

### 9. Чим Collection відрізняється від Collections?

Collection — це інтерфейс, який визначає основні операції для роботи з колекціями (додавання, видалення, перевірка наявності елементів). Він є базовим для таких спеціалізованих інтерфейсів, як List, Set, Queue.

Приклад використання:

```Java
Collection<String> myCollection = new ArrayList<>();
myCollection.add("Hello");

```

Collections — це утилітний клас, який містить статичні методи для роботи з колекціями. Він дозволяє виконувати такі операції, як сортування, пошук, синхронізація та інші маніпуляції.

Приклад використання:

```Java
List<String> list = new ArrayList<>();
list.add("Banana");
list.add("Apple");
Collections.sort(list); // Сортування списку

```
