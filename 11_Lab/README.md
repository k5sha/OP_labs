# Лабораторна робота №11
### Тема: Колекції. Множина TreeSet

### Виконано групою номер **12**

[Сама лабороторна](https://docs.google.com/document/d/115PUFfGHkWvwExS8c5SKpjcZwVauqMvq/edit)


### Контрольні питання:

### 1. Чим інтерфейс Set відрізняється від інтерфейсу Collection?

Відмінності між інтерфейсами Set і Collection у Java полягають у тому, що Set є спеціалізованим підтипом Collection, який має додаткові обмеження та специфічні властивості:
1. Загальна структура
    - Collection: є базовим інтерфейсом у Java для роботи з групами об'єктів. Він визначає загальні методи для додавання, видалення, перевірки елементів і роботи з колекціями.
    - Set: це підтип Collection, який представляє набір елементів без дублікатів.

2. Унікальність елементів
    - Collection: дозволяє зберігати дублікатні елементи, залежно від конкретної реалізації (наприклад, у List дублікатні елементи допускаються).
    - Set: гарантує, що всі елементи в колекції є унікальними. Якщо ви намагаєтеся додати дублікат, операція додавання ігнорується.

3. Порядок елементів
    - Collection: порядок елементів залежить від конкретної реалізації (наприклад, у List елементи зберігаються в тому порядку, в якому їх додали).
    - Set: не гарантує певного порядку елементів (зокрема, реалізація HashSet). Однак деякі підтипи, як-от LinkedHashSet, зберігають порядок додавання.

4. Методи та обмеження
    - Collection: визначає базові методи, як-от:
        + add(E e)
        + remove(Object o)
        + contains(Object o)
        + size()
        + iterator()
    - Set: не додає нових методів до тих, які вже є у Collection, але вводить обмеження на унікальність.

5. Основні реалізації
    - Collection:
        + ArrayList (підтримує порядок, допускає дублікатні елементи),
        + LinkedList (підтримує порядок, допускає дублікатні елементи),
        + PriorityQueue (не є Set, але зберігає пріоритетний порядок).
    - Set:
        + HashSet (швидкий доступ, порядок не гарантується),
        + LinkedHashSet (зберігає порядок додавання),
        + TreeSet (зберігає елементи у відсортованому порядку).

### 2. Чим множина відрізняється від списку?

1. Унікальність елементів
    + Множина (Set):
        - Гарантує, що всі елементи є унікальними. Якщо ви додаєте дублікат, він автоматично ігнорується.
    + Список (List):
        - Дозволяє дублікатні елементи. Можна додати один і той самий елемент кілька разів, і він зберігатиметься в різних позиціях.

2. Порядок елементів
    + Множина (Set):
        - Не гарантує порядок елементів (наприклад, у HashSet).
        - Деякі реалізації, як-от LinkedHashSet, зберігають порядок додавання, а TreeSet сортує елементи.
    + Список (List):
        - Завжди зберігає порядок, у якому елементи були додані.

3. Доступ до елементів
    + Множина (Set):
        - Не підтримує доступ до елементів за індексом. Ви можете лише ітеруватися через елементи.
    + Список (List):
        - Підтримує доступ за індексом через методи get(int index) або set(int index, E element). Елементи можна змінювати або отримувати за їх позицією.

4. Продуктивність
    + Множина (Set):
        - Швидший пошук елементів завдяки використанню хешування (у випадку HashSet).
        - Операції додавання, видалення та перевірки існування мають, як правило, O(1) (для HashSet) або O(log(n)) (для TreeSet).
    + Список (List):
        - Швидкість доступу за індексом у ArrayList становить O(1).
        - Однак операції додавання чи видалення елементів у середині списку мають O(n), оскільки елементи потрібно зміщувати.

5. Додаткові операції
    + Множина (Set):
        - Використовується для роботи з унікальними елементами. Має специфічні методи, наприклад, для роботи з підмножинами (у TreeSet).
        - Часто застосовується для перевірки наявності елемента або усунення дублікатів.
    + Список (List):
        - Підходить для послідовних структур, де важливий порядок елементів.
        - Можна вставляти елементи у певні позиції через add(int index, E element).

6. Основні реалізації
    + Множина (Set):
        - HashSet: швидкий доступ, порядок не зберігається.
        - LinkedHashSet: зберігає порядок додавання.
        - TreeSet: елементи відсортовані.
    + Список (List):
        - ArrayList: масив із динамічним розміром, швидкий доступ за індексом.
        - LinkedList: двозв’язний список, швидке додавання/видалення, але повільний доступ за індексом.

7. Приклади використання
    + Множина (Set):
        - Зберігання унікальних користувачів, IP-адрес або ідентифікаторів.
        - Використовується в ситуаціях, де порядок неважливий або потрібна унікальність.
    + Список (List):
        -Реалізація черги, послідовностей або зберігання даних, де важливий порядок і дозволені дублікатні значення.

Висновок:
    + Set – для унікальних елементів.
    + List – для послідовних структур, які допускають дублікатні елементи та доступ за індексом.

### 3. Які є переваги/недоліки використання множин у порівнянні зі списками?

1) Переваги множин:
    + Гарантована унікальність елементів
       - У множинах автоматично усуваються дублікати. Це зручно, якщо потрібно працювати лише з унікальними значеннями.
       - У списках доводиться самостійно перевіряти наявність дублікатів, що збільшує складність коду.
    + Швидкий пошук і перевірка наявності елемента
       - У реалізації HashSet перевірка наявності елемента працює за час O(1) завдяки хешуванню.
       - У списках, залежно від реалізації, пошук може займати O(n) (лінійний час).
    + Ефективна робота з великими обсягами даних
       - Множини забезпечують швидку обробку операцій на великих наборах даних, особливо якщо не важливий порядок.
    + Можливість використання підмножин
       - Реалізація TreeSet дозволяє працювати з підмножинами, виконувати сортування та інші математичні операції, як-от перетин або об’єднання.

2) Недоліки множин:
    + Відсутність порядку (у більшості реалізацій)
        - У стандартній реалізації HashSet порядок елементів не зберігається. Якщо важливий порядок, потрібно використовувати LinkedHashSet (зберігає порядок    додавання) або TreeSet (зберігає сортування), що може зменшити продуктивність.
    + Немає доступу за індексом
        - У множинах неможливо звернутися до елемента за конкретним індексом, оскільки множина не підтримує індексацію. У списках метод get(int index) дозволяє швидко отримати елемент за позицією.
    + Вища пам'ятна складність (у деяких випадках)
        - Реалізація HashSet використовує хешування, що може потребувати більше пам’яті, ніж список, особливо для невеликих наборів даних.
    + Складніша вставка у впорядкованому вигляді
        - У множинах не можна напряму додати елемент у певну позицію, як це можливо у списках через add(int index, E element).

3) Переваги списків:
    + Збереження порядку
        - Елементи в списках завжди розташовані в тому порядку, в якому були додані (наприклад, у ArrayList).
    + Доступ за індексом
        - У списках можна отримати або змінити елемент за його індексом, що особливо зручно для послідовностей.
    + Гнучке додавання та видалення
        - У LinkedList додавання або видалення елементів у середині списку відбувається ефективно.
    + Підтримка дублікатів
        - Списки дозволяють зберігати дублікатні значення, що корисно, якщо порядок або кількість однакових елементів має значення.

4) Недоліки списків:
    + Повільніший пошук
        - Для перевірки наявності елемента список змушений виконувати повний обхід (лінійний час O(n)), що значно повільніше порівняно з множинами.
    + Не усуває дублікатів автоматично
        - Якщо потрібно уникнути дублікатів у списках, доведеться вручну реалізовувати перевірки.
    + Менш ефективна робота з великими наборами даних
        - Для великих обсягів даних операції додавання, видалення та перевірки у списках можуть бути повільнішими порівняно з множинами.

1. Коли використовувати множини, а коли списки?
    + Множини (Set):
        - Коли потрібно забезпечити унікальність елементів.
        - Для швидкого пошуку або перевірки наявності елемента.
        - Коли порядок або індексація не мають значення.
    + Списки (List):
        - Коли важливий порядок елементів.
        - Коли потрібен доступ за індексом.
        - Якщо потрібна робота з послідовностями, які можуть містити дублікатні значення.

### 4. Чим інтерфейс SortedSet відрізняється від Set?
1. Визначення
    + Set:
      - Базовий інтерфейс, що представляє множину унікальних елементів без гарантій щодо їх порядку.
      - Дозволяє будь-яку реалізацію множини, незалежно від способу зберігання або упорядкування.
    + SortedSet:
      - Розширює інтерфейс Set і додає функціональність для роботи з елементами, які автоматично зберігаються у впорядкованому вигляді.
      - Порядок елементів визначається їх природним порядком (як у випадку з Comparable) або за допомогою заданого Comparator.

2. Порядок елементів
    + Set:
       - Не гарантує жодного порядку елементів.
       - У HashSet, наприклад, порядок елементів може змінюватися при кожному виконанні програми.
    + SortedSet:
        - Гарантує, що елементи завжди розташовані у впорядкованому вигляді:
        - Реалізація TreeSet автоматично підтримує цей порядок.

3. Додаткові методи в SortedSet

SortedSet додає кілька специфічних методів для роботи з упорядкованими елементами:

    Comparator<? super E> comparator()
        Повертає компаратор, який використовується для сортування.
        Якщо компаратор не задано, використовується природний порядок.

    E first()
        Повертає перший (найменший) елемент множини.

    E last()
        Повертає останній (найбільший) елемент множини.

    SortedSet<E> headSet(E toElement)
        Повертає підмножину всіх елементів, менших за toElement.

    SortedSet<E> tailSet(E fromElement)
        Повертає підмножину всіх елементів, більших або рівних fromElement.

    SortedSet<E> subSet(E fromElement, E toElement)
        Повертає підмножину елементів між fromElement (включно) і toElement (не включаючи).

4. Реалізації

    Set:
        Основні реалізації:
            HashSet (швидкий доступ, порядок не гарантується),
            LinkedHashSet (зберігає порядок додавання).
    SortedSet:
        Основна реалізація:
            TreeSet (реалізований на основі дерева, підтримує порядок).
            Для TreeSet порядок елементів забезпечується алгоритмом балансування (червоних-чорних дерев).

5. Використання

    Set:
        Використовується, коли унікальність елементів важлива, але порядок не має значення.
        Наприклад, для зберігання унікальних ідентифікаторів або наборів без пріоритету.

    SortedSet:
        Використовується, коли елементи повинні бути впорядковані, і потрібен доступ до підмножин або крайніх елементів.
        Наприклад, для зберігання відсортованих даних (рахунки, рейтинги тощо).
### 5. Чому в назві класу TreeSet є слово Tree? 
### 6. Якими критеріям мають відповідати об’єкти для того, щоб посилання на них можна було зберігати у TreeSet?
### 7. Чому в TreeSet не слід зберігати посилання на мутабельні об’єкти?
