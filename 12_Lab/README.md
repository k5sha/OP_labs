# Лабораторна робота №12
### Тема: Колекції. Множина HashSet. Асоціативні масиви Map.

### Виконано групою номер **12**

[Сама лабороторна](https://docs.google.com/document/d/10zPma8FUx5ajKIB2z93Mh72yY02DIdu-/edit)

### Контрольні питання:

### 1. Чим інтерфейс Set відрізняється від інтерфейсів Collection та List?

# Специфікація інтерфейсів у Java

## 1. Collection
- Це базовий інтерфейс для роботи з колекціями в Java.
- Визначає загальні методи, які підтримують усі типи колекцій:
  - `add()`, `remove()`, `size()`, `clear()`, тощо.
- Не визначає специфічну поведінку, а є каркасом для інших колекцій.

## 2. Set
- Розширює `Collection` і гарантує, що **жоден елемент не може бути дубльованим** (унікальність елементів).
- Не гарантує порядок елементів (залежить від реалізації):
  - **`HashSet`**: порядок не гарантується.
  - **`TreeSet`**: зберігає елементи у відсортованому порядку.
  - **`LinkedHashSet`**: гарантує порядок вставки.
- Використовується, коли потрібно уникнути дублювання.

## 3. List
- Розширює `Collection` і підтримує **впорядковану колекцію елементів**.
- Дозволяє дублювання елементів.
- Забезпечує доступ до елементів за індексом:
  - Методи: `get(index)`, `set(index, value)`.
- Використовується, коли важливий порядок елементів.

---

# Реалізації

## 1. Set
- **`HashSet`**: Використовує хешування, порядок елементів не гарантується.
- **`TreeSet`**: Зберігає елементи у відсортованому порядку (природний порядок або через компаратор).
- **`LinkedHashSet`**: Гарантує порядок вставки елементів.

## 2. List
- **`ArrayList`**: Масив, що динамічно змінює розмір.
- **`LinkedList`**: Двобічно зв’язаний список.
- **`Vector`**: Стара реалізація, яка синхронізована.

## 3. Collection
- Є базовим каркасом для всіх типів колекцій:
  - Включає `Set`, `List`, `Queue` тощо.

---

# Використання

## 1. Set
- Використовується для зберігання унікальних значень.
- Підходить для таких задач:
  - Математичні множини.
  - Зберігання унікальних ідентифікаторів.
  - Перевірка наявності елемента.

## 2. List
- Використовується, коли важливий порядок елементів.
- Забезпечує швидкий доступ за індексом.
- Приклади:
  - Списки завдань.
  - Упорядковані дані.

## 3. Collection
- Використовується як загальний інтерфейс, коли неважливо, який саме тип колекції використовується.


### 2. HashSet відрізняється від TreeSet?

HashSet і TreeSet — це реалізації інтерфейсу Set у Java, але вони мають значні відмінності у своїй роботі, поведінці та використанні. Ось детальне порівняння:

| **Критерій**            | **HashSet**                                            | **TreeSet**                                       |
|-------------------------|------------------------------------------------------|--------------------------------------------------|
| **Порядок елементів**    | Не гарантує порядку елементів.                        | Гарантує **сортування** (за природним порядком або компаратором). |
| **Продуктивність**       | Швидший для операцій `add`, `remove`, `contains`.       | Повільніший через необхідність підтримки порядку. |
| **Реалізація**           | Використовує **HashMap** для зберігання даних.         | Використовує **TreeMap** на основі червоно-чорного дерева. |
| **Null-значення**        | Дозволяє одне `null`-значення.                         | Не дозволяє `null`-значення (викидає `NullPointerException`). |
| **Сортування**           | Елементи не впорядковуються.                          | Елементи завжди відсортовані.                     |

| **Операція**            | **HashSet**            | **TreeSet**            |
|-------------------------|-----------------------|------------------------|
| **add**                 | O(1) в середньому     | O(log n)               |
| **remove**              | O(1) в середньому     | O(log n)               |
| **contains**            | O(1) в середньому     | O(log n)               |

### Особливості

#### HashSet:
- Використовує механізм хешування для зберігання елементів.
- Не впорядковує елементи.
- Ідеальний вибір, коли потрібна швидкість операцій і порядок елементів не має значення.

#### TreeSet:
- Використовує структуру **червоного-чорного дерева**, щоб зберігати елементи впорядкованими.
- Природний порядок визначається реалізацією інтерфейсу **Comparable** у класі елементів (або переданим компаратором).
- Підходить, коли потрібно працювати з впорядкованими множинами, наприклад:
  - Зберігати відсортовані дані.
  - Знаходити елементи в діапазоні (методи `subSet`, `headSet`, `tailSet`).

### 3. Що таке хешування, хеш, хеш-код, хеш-функція?

### Що таке хешування?
Хешування — це процес перетворення даних (наприклад, об'єкта чи рядка) в унікальне числове значення фіксованої довжини. Це значення називається **хеш-кодом**. У Java хешування використовується для оптимізації доступу до даних, зокрема в структурах даних, таких як **HashMap**, **HashSet**.

---

### Хеш
**Хеш** — це результат виконання хеш-функції. Це числове представлення об'єкта, яке можна використовувати для ефективного порівняння або доступу до об'єкта.

Приклад :
```java
String str = "example";
int hash = str.hashCode(); // Отримуємо хеш-код рядка
System.out.println(hash);  // Вивід хеш-коду
```

Хеш-код — це числове значення, що повертається методом hashCode() у Java. Метод hashCode() є частиною класу Object і визначається кожним класом для об'єктів, які потрібно хешувати.

Властивості хеш-коду:
  + Якщо два об'єкти рівні (equals() повертає true), то їхні хеш-коди мають бути однаковими.
  + Якщо два об'єкти мають однаковий хеш-код, це не означає, що вони рівні (можлива колізія).

Приклад :
```java
String str1 = "example";
String str2 = "example";

System.out.println(str1.hashCode()); // Хеш-код str1
System.out.println(str2.hashCode()); // Хеш-код str2 (такий самий, як у str1)

```
Хеш-функція — це функція, яка перетворює вхідні дані в хеш-код. У Java стандартна реалізація хеш-функції визначена в методі hashCode().

Вимоги до хеш-функції:
    + Має бути швидкою для обчислення.
    + Має мінімізувати кількість колізій (різні дані не повинні мати однаковий хеш-код, наскільки це можливо).
    + Повинна забезпечувати однаковий результат для одного і того ж об'єкта.

Приклад :
```java
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int hashCode() {
        return name.hashCode() * 31 + age;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return age == person.age && name.equals(person.name);
    }
}
```

### 4. Яким вимогам має відповідати коректна хеш-функція?

Хеш-функція повинна відповідати наступним вимогам, щоб забезпечити коректність і ефективність:

1. **Стабільність**:
   - Для одного і того ж об'єкта хеш-код повинен залишатися незмінним протягом життєвого циклу об'єкта, якщо його стан не змінюється.

2. **Взаємозв'язок з методом `equals`**:
   - Якщо два об'єкти рівні (`equals` повертає `true`), то їхні хеш-коди повинні бути однаковими.
   - Якщо два об'єкти не рівні, їхні хеш-коди **можуть** бути однаковими, але бажано, щоб це траплялося якомога рідше (уникати колізій).

3. **Швидкість обчислення**:
   - Хеш-код має обчислюватися швидко, навіть для великих об'єктів.

4. **Рівномірний розподіл**:
   - Хеш-функція повинна забезпечувати рівномірний розподіл хеш-кодів, щоб уникнути колізій у хеш-таблицях.

5. **Уникнення колізій**:
   - Хоча колізії (однаковий хеш-код для різних об'єктів) можливі, хеш-функція повинна мінімізувати їх кількість.

---

# Приклад коректної хеш-функції
Ось приклад реалізації хеш-функції для класу, що відповідає вказаним вимогам:

```java
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int hashCode() {
        // Використання якісного алгоритму обчислення хеш-коду
        int result = 17;
        result = 31 * result + (name != null ? name.hashCode() : 0);
        result = 31 * result + age;
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return age == person.age && (name != null ? name.equals(person.name) : person.name == null);
    }
}
```

### 5. Які властивості притаманні хорошій хеш-функції?

Хороша хеш-функція повинна мати такі властивості:

1. **Стабільність**:
   - Для одного і того ж об'єкта, який не змінюється, хеш-код повинен залишатися постійним.

2. **Сумісність з `equals`**:
   - Якщо два об'єкти рівні (метод `equals` повертає `true`), їх хеш-коди повинні бути однаковими.

3. **Мінімізація колізій**:
   - Для різних об'єктів бажано, щоб хеш-коди були різними, зменшуючи ймовірність колізій.

4. **Рівномірний розподіл**:
   - Значення хеш-кодів повинні бути рівномірно розподілені, щоб уникнути скупчення значень у хеш-таблиці.

5. **Швидкість обчислення**:
   - Хеш-функція має бути ефективною і швидкою, навіть для великих об'єктів.

6. **Використання всіх значущих полів**:
   - Хеш-функція повинна враховувати всі значущі поля об'єкта для забезпечення унікальності.

---

# Приклад хорошої хеш-функції
Ось приклад реалізації хеш-функції, яка відповідає вищезазначеним властивостям:

```java
class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public int hashCode() {
        // Використання простого, але ефективного алгоритму для створення хеш-коду
        int result = 17; // Початкове значення
        result = 31 * result + (name != null ? name.hashCode() : 0); // Хеш для поля name
        result = 31 * result + age; // Хеш для поля age
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return age == person.age && (name != null ? name.equals(person.name) : person.name == null);
    }
}
```

### 6. Якими критеріям мають відповідати об’єкти для того, щоб посилання на них можна було зберігати у HashSet?
# Критерії для зберігання об’єктів у HashSet

Щоб об’єкти могли бути коректно збережені в **HashSet**, вони повинні відповідати таким критеріям:

1. **Перевизначення `hashCode()`**:
   - Клас об'єкта повинен перевизначати метод `hashCode()`.
   - Хеш-код об'єкта використовується для визначення, в який "бакет" (внутрішній контейнер) буде поміщено об'єкт.
   - Хеш-коди повинні бути стабільними та рівномірно розподіленими.

2. **Перевизначення `equals()`**:
   - Клас об'єкта повинен перевизначати метод `equals()`.
   - Якщо два об'єкти рівні (тобто `equals()` повертає `true`), вони не повинні зберігатися як окремі елементи в HashSet.

3. **Стабільність `hashCode()` і `equals()`**:
   - Якщо стан об'єкта, який впливає на `hashCode()` або `equals()`, змінюється, це може порушити коректність роботи HashSet.
   - Рекомендується не змінювати об'єкти після їх додавання в HashSet.

---

# Приклад реалізації класу для використання в HashSet

```java
import java.util.HashSet;

class Person {
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    // Перевизначення hashCode()
    @Override
    public int hashCode() {
        int result = 17;
        result = 31 * result + (name != null ? name.hashCode() : 0);
        result = 31 * result + age;
        return result;
    }

    // Перевизначення equals()
    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return age == person.age && (name != null ? name.equals(person.name) : person.name == null);
    }

    @Override
    public String toString() {
        return "Person{name='" + name + "', age=" + age + "}";
    }
}

public class HashSetExample {
    public static void main(String[] args) {
        HashSet<Person> set = new HashSet<>();

        // Додавання об'єктів до HashSet
        set.add(new Person("Alice", 25));
        set.add(new Person("Bob", 30));
        set.add(new Person("Alice", 25)); // Дублікати не додаються

        // Виведення елементів HashSet
        System.out.println(set); // [Person{name='Alice', age=25}, Person{name='Bob', age=30}]
    }
}
```

### 7. Які є переваги/недоліки використання HashSetу порівнянні з TreeSet?

## Переваги HashSet
1. **Швидкість**:
   - Операції вставки, видалення та перевірки наявності виконуються в середньому за O(1), завдяки хешуванню.
   - Значно швидший у порівнянні з TreeSet для великих наборів даних.

2. **Проста реалізація**:
   - Використовує `HashMap` для зберігання елементів.
   - Менше пам'яті та ресурсів потрібні для управління, оскільки не підтримує впорядкування.

3. **Дозволяє одне `null`-значення**:
   - HashSet дозволяє зберігати одне `null`, на відміну від TreeSet, який не підтримує `null`.

---

## Недоліки HashSet
1. **Відсутність впорядкування**:
   - Елементи не впорядковані, тому неможливо отримати їх у відсортованому вигляді.
   - Якщо потрібен порядок або сортування, доведеться додатково сортувати колекцію.

2. **Колізії**:
   - Можливі колізії хеш-кодів, які можуть вплинути на продуктивність.

3. **Немає підтримки діапазонів**:
   - HashSet не дозволяє витягувати підмножини чи працювати з діапазонами, як TreeSet (`subSet`, `headSet`, `tailSet`).

---

## Переваги TreeSet
1. **Впорядкування**:
   - Елементи завжди зберігаються у впорядкованому вигляді (за природним порядком або на основі компаратора).

2. **Підтримка діапазонів**:
   - Методи `subSet`, `headSet`, `tailSet` дозволяють працювати з частинами множини.

3. **Менше залежить від хеш-функції**:
   - TreeSet не використовує хешування, тому колізії не є проблемою.

---

## Недоліки TreeSet
1. **Повільніша продуктивність**:
   - Операції вставки, видалення та перевірки наявності виконуються за O(log n), оскільки TreeSet побудований на основі червоно-чорного дерева.

2. **Вища витрата пам'яті**:
   - Для підтримки структури дерева потрібно більше пам'яті.

3. **Не підтримує `null`**:
   - TreeSet не дозволяє зберігати `null`, оскільки сортування потребує порівняння елементів, і `null` не може бути порівняний.

---

## Таблиця порівняння

| **Критерій**              | **HashSet**                          | **TreeSet**                          |
|---------------------------|---------------------------------------|---------------------------------------|
| **Швидкість операцій**     | O(1) (у середньому)                  | O(log n)                             |
| **Впорядкування елементів**| Не впорядковує                      | Завжди впорядковані                  |
| **Підтримка діапазонів**   | Ні                                  | Так (`subSet`, `headSet`, `tailSet`) |
| **Підтримка `null`**       | Дозволяє одне `null`-значення        | Не підтримує `null`                  |
| **Витрати пам'яті**        | Менші                               | Більші                               |
| **Залежність від хеш-функції** | Так                               | Ні                                   |

---

## Висновок
- Використовуйте **HashSet**, якщо:
  - Потрібна висока продуктивність.
  - Порядок елементів не важливий.
  - Потрібно зберігати `null`.

- Використовуйте **TreeSet**, якщо:
  - Потрібен відсортований набір даних.
  - Необхідно працювати з діапазонами.
  - Підтримка `null` не потрібна.

### 8. Чим поняття sizeвідрізняється від capacity? Чи може sizeбути більший за capacity? Чи може capacityбути більший за size?Якщо так, то за яких умов?

# Різниця між поняттями `size` та `capacity` у Java

## Що таке `size`?
- **`size`** — це кількість елементів, які фактично зберігаються в колекції (наприклад, у `ArrayList`).
- Відображає поточний стан наповненості колекції.

## Що таке `capacity`?
- **`capacity`** — це кількість елементів, які колекція може зберігати до того, як буде необхідне збільшення її розміру.
- Визначає резервовану пам'ять для зберігання елементів.

---

## Чи може `size` бути більшим за `capacity`?
- **Ні**, значення `size` **ніколи** не може перевищувати `capacity`.
- Якщо до колекції додається більше елементів, ніж дозволяє поточна ємність (`capacity`), відбувається **автоматичне збільшення ємності**, після чого `capacity` стає більшим.

---

## Чи може `capacity` бути більшим за `size`?
- **Так**, у більшості випадків `capacity` **більший** за `size`.
- Це відбувається, оскільки при створенні колекцій зазвичай резервується більше пам'яті, ніж необхідно для поточних елементів, щоб уникнути частих перерозподілів пам'яті.

---

## Умови, за яких `capacity > size`
1. **Після ініціалізації колекції**:
   - Наприклад, при створенні `ArrayList` з вказаною початковою ємністю:
   ```java
   ArrayList<Integer> list = new ArrayList<>(10); // capacity = 10, size = 0
   ```
   
### 9. Що таке load factorта на що і як він впливає?

## Що таке `load factor`?
- **`Load factor`** (коефіцієнт заповнення) — це числовий параметр, який визначає, наскільки заповненою може бути хеш-таблиця перед тим, як її ємність буде автоматично збільшена.
- Він розраховується за формулою:
- load factor = кількість_елементів / поточна_ємність
- Значення за замовчуванням для `HashMap` у Java: **0.75** (75%).

---

## Як працює `load factor`?
- Коли кількість елементів у хеш-таблиці досягає величини:
- поточна_ємність * load factor
хеш-таблиця автоматично **подвоює свою ємність**, і всі елементи реорганізуються у нову таблицю.

---

## Вплив `load factor` на продуктивність
1. **Низький `load factor` (наприклад, 0.5)**:
 - Зменшує кількість колізій, оскільки елементи розподіляються рівномірніше.
 - Займає більше пам'яті, оскільки ємність збільшується раніше.

2. **Високий `load factor` (наприклад, 0.9)**:
 - Економить пам'ять, оскільки таблиця наповнюється сильніше перед збільшенням ємності.
 - Може спричинити більшу кількість колізій, що знижує продуктивність.

---

## Як встановити `load factor`?
- При створенні об’єкта `HashMap` можна вказати власний `load factor`:
```java
HashMap<Integer, String> map = new HashMap<>(initialCapacity, loadFactor);
```

### 10. Що таке асоціативний масив? Чим ключ відрізняється від значення?

# Що таке асоціативний масив?

## Визначення
**Асоціативний масив** — це структура даних, яка зберігає пари **ключ—значення**. Кожен ключ унікальний і пов'язаний із певним значенням. Ця структура дозволяє швидко шукати значення за його ключем.

У Java асоціативний масив реалізується через інтерфейс **Map**, основними реалізаціями якого є:
- **HashMap** (не гарантує порядку).
- **TreeMap** (елементи впорядковуються за ключем).
- **LinkedHashMap** (зберігає порядок вставки).

---

## Структура асоціативного масиву
- **Ключ (key)**: Унікальний ідентифікатор, який використовується для доступу до значення.
- **Значення (value)**: Дані, які асоціюються з ключем.

---

## Відмінності між ключем і значенням

| **Критерій**       | **Ключ (key)**                        | **Значення (value)**                    |
|--------------------|---------------------------------------|-----------------------------------------|
| **Унікальність**   | Повинен бути унікальним               | Може повторюватися                      |
| **Призначення**    | Використовується для пошуку           | Зберігає дані, які пов'язані з ключем   |
| **Обов'язковість** | Обов'язковий для кожної пари          | Може бути `null`                        |

---

## Приклад створення та використання асоціативного масиву в Java
```java
import java.util.HashMap;
import java.util.Map;

public class AssociativeArrayExample {
    public static void main(String[] args) {
        // Створюємо асоціативний масив (HashMap)
        Map<String, Integer> map = new HashMap<>();

        // Додаємо пари ключ—значення
        map.put("Apple", 10);
        map.put("Banana", 20);
        map.put("Orange", 30);

        // Доступ до значення за ключем
        System.out.println("Value for 'Apple': " + map.get("Apple")); // 10

        // Перевірка наявності ключа
        System.out.println("Contains 'Banana': " + map.containsKey("Banana")); // true

        // Перевірка наявності значення
        System.out.println("Contains value 30: " + map.containsValue(30)); // true

        // Видалення пари за ключем
        map.remove("Apple");

        // Перебір усіх пар ключ—значення
        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println("Key: " + entry.getKey() + ", Value: " + entry.getValue());
        }
    }
}
```

### 11. Чи може в асоціативному масиві зберігатись кілька однакових ключів або однакових значень?

## Ключі (Keys)
- **Ні**, в асоціативному масиві **не може бути кількох однакових ключів**.
- Ключі повинні бути унікальними. Якщо ви додаєте пару з ключем, який уже існує, нове значення замінює старе.

**Приклад:**
```java
import java.util.HashMap;
import java.util.Map;

public class DuplicateKeysExample {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();

        // Додаємо пари ключ—значення
        map.put("Apple", 10);
        map.put("Banana", 20);
        map.put("Apple", 30); // Перезаписує значення для ключа "Apple"

        System.out.println(map); // {Banana=20, Apple=30}
    }
}
```

### 12. До яких наслідків може привести зберігання неімутабельних об’єктів у HashSet, у HashMapв якості ключа та у HashMapв якості значення?

## Проблема неімутабельних об'єктів
Неімутабельні об'єкти — це об'єкти, стан яких можна змінити після створення. Зберігання таких об'єктів у `HashSet` або використання їх у `HashMap` (як ключів або значень) може призводити до непередбачуваних результатів, оскільки структури даних залежать від стабільності `hashCode()` і `equals()`.

---

## 1. Зберігання неімутабельних об'єктів у `HashSet`

### Потенційні наслідки:
1. **Порушення унікальності**:
   - Якщо стан об’єкта змінюється так, що його хеш-код змінюється, `HashSet` може втратити можливість коректно визначити унікальність елементів.
2. **Проблеми з пошуком**:
   - Змінений об'єкт може стати "невидимим" для методів, таких як `contains()`, оскільки його хеш-код більше не відповідає "бакету", де він знаходиться.

### Приклад:
```java
import java.util.HashSet;

class MutableObject {
    int value;

    public MutableObject(int value) {
        this.value = value;
    }

    @Override
    public int hashCode() {
        return value; // Хеш-код залежить від значення
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        MutableObject that = (MutableObject) obj;
        return value == that.value;
    }
}

public class HashSetExample {
    public static void main(String[] args) {
        HashSet<MutableObject> set = new HashSet<>();

        MutableObject obj = new MutableObject(10);
        set.add(obj);

        System.out.println("Set contains obj: " + set.contains(obj)); // true

        // Змінюємо об'єкт
        obj.value = 20;

        System.out.println("Set contains obj after mutation: " + set.contains(obj)); // false
        System.out.println("Set: " + set); // Об'єкт залишається у "неправильному" бакеті
    }
}
```
### 13. Чи можуть об’єкти без інтерфейсу Comparable зберігатись у TreeMap? 

## Відповідь
**Так**, об’єкти, які не реалізують інтерфейс `Comparable`, можуть зберігатись у `TreeMap`, але за умови, що ви надасте зовнішній **`Comparator`** при створенні `TreeMap`. Без реалізації `Comparable` або без наданого `Comparator`, `TreeMap` не зможе впорядкувати об'єкти, і це призведе до помилки під час виконання.

---

## Коли потрібен інтерфейс `Comparable`?
- Якщо об’єкти, які зберігаються у `TreeMap`, мають бути впорядковані за їх природним порядком, то вони повинні реалізувати інтерфейс **`Comparable`** і перевизначати метод `compareTo()`.

### Приклад:
```java
import java.util.TreeMap;

class Person implements Comparable<Person> {
    String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public int compareTo(Person other) {
        return this.name.compareTo(other.name); // Порівняння за іменем
    }

    @Override
    public String toString() {
        return name;
    }
}

public class TreeMapExampleWithComparable {
    public static void main(String[] args) {
        TreeMap<Person, Integer> treeMap = new TreeMap<>();
        treeMap.put(new Person("Alice"), 25);
        treeMap.put(new Person("Bob"), 30);

        System.out.println(treeMap); // {Alice=25, Bob=30}
    }
}
```

### 14. Чи можуть об’єкти без інтерфейсу Comparable зберігатись у HashMap? Чи взагалі впливає на щось наявність у об’єктів інтерфейсу Comparable при зберіганні у HashMap?
# Чи можуть об’єкти без інтерфейсу `Comparable` зберігатись у `HashMap`?

## Відповідь
**Так**, об’єкти, які не реалізують інтерфейс `Comparable`, можуть зберігатись у `HashMap`.  
На відміну від `TreeMap`, `HashMap` **не потребує** впорядкування елементів, тому реалізація `Comparable` не є обов'язковою.  
`HashMap` використовує методи `hashCode()` і `equals()` для роботи з ключами, а не `compareTo()`.

---

## Вплив наявності інтерфейсу `Comparable` у об’єктів при зберіганні в `HashMap`
- Реалізація `Comparable` **не впливає** на функціональність `HashMap`, оскільки `HashMap` не сортує ключі чи значення.
- Основні методи, які використовуються у `HashMap`:
  - `hashCode()` — для визначення "бакету" ключа.
  - `equals()` — для перевірки рівності ключів.

---

## Приклад зберігання об'єктів без `Comparable` у `HashMap`

```java
import java.util.HashMap;

class Person {
    String name;

    public Person(String name) {
        this.name = name;
    }

    @Override
    public int hashCode() {
        return name.hashCode(); // Використання імені для хеш-коду
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Person person = (Person) obj;
        return name.equals(person.name);
    }

    @Override
    public String toString() {
        return name;
    }
}

public class HashMapExample {
    public static void main(String[] args) {
        HashMap<Person, Integer> map = new HashMap<>();

        // Додаємо об'єкти як ключі
        map.put(new Person("Alice"), 25);
        map.put(new Person("Bob"), 30);

        System.out.println("HashMap: " + map);
    }
}
```
