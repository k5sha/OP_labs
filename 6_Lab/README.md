# Лабораторна робота №6
### Тема: Алгоритми сортування

### Виконано групою номер **12**

[Сама лабороторна](https://docs.google.com/document/d/11YSuDl9No2fjLnjLZvlgNIMhvm_2v0r-/edit)


### Контрольні питання:

### 1. Порівняйте та назвіть переваги та недоліки таких методів сортування: сортування бульбашкою, сортування вибором, сортування вставкою.

1. Сортування бульбашкою (Bubble Sort)
+ Переваги:
   - Простота: Легко зрозуміти та реалізувати. Ідеально підходить для навчальних цілей.
   - Мінімальні вимоги до пам'яті: Використовує лише базову пам'ять (O(1)) для додаткових операцій, оскільки працює безпосередньо над вхідним масивом.
   - Виявлення вже відсортованих масивів: Якщо під час проходу не було жодного обміну, алгоритм може завершити роботу раніше, що робить його дещо ефективнішим на майже відсортованих масивах.
+ Недоліки:
   - Низька ефективність: Часова складність в найгіршому і середньому випадках O(n²), що робить його непридатним для великих наборів даних.
   - Часті обміни: Вимагає багатьох операцій обміну елементів, що може бути повільно на деяких системах.

2. Сортування вибором (Selection Sort)
+ Переваги:
   - Простота: Легко зрозуміти та реалізувати.
   - Мінімальна кількість обмінів: В порівнянні з сортуванням бульбашкою, цей метод виконує значно менше обмінів (максимум n обмінів для масиву розміру n).
   - Мінімальні вимоги до пам'яті: Також має додаткову складність по пам'яті O(1).
+ Недоліки:
   - Низька ефективність: Часова складність O(n²) в найгіршому і середньому випадках, незалежно від того, наскільки вже відсортований масив.
   - Повільний для великих масивів: Алгоритм завжди перебирає весь масив, навіть якщо він майже відсортований.

3. Сортування вставками (Insertion Sort)
+ Переваги:
   - Ефективність на майже відсортованих масивах: Відмінно працює для масивів, які майже відсортовані. У найкращому випадку (вже відсортований масив) має часову складність O(n).
   - Онлайн алгоритм: Може використовуватися для сортування елементів у реальному часі, коли нові елементи поступово додаються до набору.
   - Мінімальні вимоги до пам'яті: Потребує лише O(1) додаткової пам'яті.
+ Недоліки:
   - Низька ефективність для великих масивів: Часова складність у середньому і найгіршому випадках також O(n²), тому не підходить для великих наборів даних.
   - Порівняння і вставка: Для кожного елемента потрібно знайти правильне місце вставки, що може бути повільно для довгих списків.

### 2. Оцініть кожен з методів відповідно до наступних критеріїв:
```
 - час роботи;
 - потреби у додатковій пам’яті;
 - стабільність.
```
  За якими ще критеріями ви можете порівняти ці алгоритми? 

1. Сортування бульбашкою (Bubble Sort)
 + Час роботи:
   - Найгірший і середній випадок: O(n²)
   - Найкращий випадок: O(n) (якщо масив вже відсортований і реалізація включає перевірку на відсутність обмінів).
 +  Потреби у додатковій пам’яті:
    - O(1) – працює без використання додаткової пам’яті, оскільки обміни відбуваються безпосередньо в масиві.
 + Стабільність:
    - Стабільний – елементи з однаковими ключами зберігають свій відносний порядок після сортування.

2. Сортування вибором (Selection Sort)
 +  Час роботи:
    - Найгірший і середній випадок: O(n²)
    - Найкращий випадок: O(n²) (не має переваг для вже відсортованих масивів, оскільки завжди проходить через весь масив).
 + Потреби у додатковій пам’яті:
    - O(1) – не потребує додаткової пам’яті, оскільки працює безпосередньо в масиві.
 + Стабільність:
    - Нестабільний – може змінювати відносний порядок елементів з однаковими ключами.
 
3. Сортування вставками (Insertion Sort)
 + Час роботи:
    - Найгірший і середній випадок: O(n²)
    -  Найкращий випадок: O(n) (для вже відсортованого або майже відсортованого масиву).
 + Потреби у додатковій пам’яті:
    - O(1) – не використовує додаткової пам’яті.
 + Стабільність:
    - Стабільний – зберігає відносний порядок елементів з однаковими ключами.

### 3. Який випадок є найкращім або найгіршим для роботи цих алгоритмів? (Наприклад: частково відсортований масив або масив, відсортований у зворотному порядку). Який з методів забезпечить у цих випадках найкращій/найгірший результат?

1. Найкращий результат у вже відсортованому масиві:
   - Сортування вставками: Виконується за O(n), оскільки немає потреби в пересуваннях елементів.
   - Сортування бульбашкою (з оптимізацією): Виконується за O(n), якщо реалізована перевірка на відсутність обмінів.
   - Сортування вибором: Завжди O(n²), незалежно від відсортованості.

2. Найгірший результат у масиві, відсортованому у зворотному порядку:
   - Сортування вставками: Найгірший час O(n²), оскільки кожен елемент потрібно вставляти на початок.
   - Сортування бульбашкою: Найгірший час O(n²) через велику кількість обмінів.
   - Сортування вибором: O(n²) – однаковий час для всіх випадків, але кількість обмінів менша, ніж у сортуванні бульбашкою.

3. Частково відсортовані масиви:
   - Сортування вставками: Найкраще підходить, оскільки швидкість може наближатися до O(n).
   - Сортування бульбашкою: Може мати кращу продуктивність у порівнянні з найгіршим випадком, але все одно має низьку ефективність для великих масивів.
   - Сортування вибором: O(n²), не має переваг для частково відсортованих масивів.
### 4. Що означають позначення O(1), O(n), O(n2)?

1. O(1) – Постійна складність
    _Що це означає_: Час виконання алгоритму не залежить від розміру вхідних даних. Незалежно від того, скільки елементів в обробці, алгоритм виконує одну і ту саму кількість операцій.

2. O(n) – Лінійна складність
    _Що це означає_: Час виконання алгоритму пропорційно збільшується разом зі збільшенням кількості елементів. Тобто, якщо вхідний масив містить 10 елементів, алгоритм виконає приблизно 10 операцій; якщо 100 елементів — 100 операцій.

3. O(n²) – Квадратична складність
    _Що це означає_: Час виконання алгоритму зростає пропорційно квадрату кількості вхідних елементів. Наприклад, якщо вхід містить 10 елементів, алгоритм виконає приблизно 100 операцій; якщо 100 елементів — 10 000 операцій.
